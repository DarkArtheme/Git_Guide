# Основные команды

Совершить коммит в выбранную ветку
> **git commit**
> 
Создание ветки с названием newImage
> **git branch** newImage
> 
Выбор ветки 
> **git checkout** \[имя ветки\]
> 
Одновременное создание и выбор ветки
> **git checkout -b** \[имя ветки\]
> 
Слияние ветки с указанным именем с текущей выбранной веткой
> **git merge** \[имя ветки\]
> 
Переместить выбранную ветку коммитов, поместить ее после ветки с указанным именем
> **git rebase** \[имя ветки\]
> 
# HEAD и относительные ссылки
<p>HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данным момент работаем.</p>

<p>HEAD всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD.</p>

<p>Обычно HEAD указывает на имя ветки (например, bugFix). Когда вы делаете коммит, статус ветки bugFix меняется и это изменение видно через HEAD.</p>


<p>Как мы уже говорили, указание на коммит при помощи его хеша - не самый удобный способ, поэтому Git поддерживает <b>относительные ссылки</b> и они прекрасны!</p>

<p>С относительными ссылками можно начать с какого-либо удобного места (например, с ветки bugFix или от HEAD) и двигаться от него</p>

Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:

* Перемещение на один коммит назад: ^ (*Пример:* **git checkout main^**)
* Перемещение на num коммитов назад:\~\<num\> (*Пример:* **git checkout main~4**)

## Перемещение веток

Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции **-f**. Например, команда:

> **git branch -f** main *HEAD~3*

Переместит (принудительно) ветку main на три родителя назад от HEAD.

## Отмена изменений

Есть много путей для отмены изменений в Git. Так же как и коммит, отмена изменений в Git возможна и на низком уровне (добавление в коммит отдельных файлов и наборов строк), и на высоком (как изменения реально отменяются). Сейчас сфокусируемся на высокоуровневой части.<br>

Есть два основных способа отмены изменений в Git: первый - это **git reset**, а второй - **git revert**

- **git reset** отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; **git reset** перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.

> **git reset** *HEAD^*
> 
- **git reset** отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи. Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать **git revert**. Посмотрим, как это работает

> **git revert** *HEAD*

Забавно, появился новый коммит. Дело в том, что новый коммит *C2'* просто содержит изменения, полностью противоположные тем, что сделаны в коммите *C2*.

После **revert** можно сделать **push** и поделиться изменениями с остальными.

# Перемещение изменений
Итак, мы уже освоили основы Git: коммиты, ветки, перемещение по дереву изменений. Уже этих знаний достаточно, чтобы овладеть 90% мощью Git-репозиториев и покрыть нужды разработчиков.

А оставшиеся 10% будут очень полезны при сложных workflow (или если ты попал в сложную ситуацию). Теперь речь пойдёт о перемещении изменений — возможности, позволяющей разработчику сказать "Хочу, чтобы эти изменения были вот тут, а вот эти — вон там" и получить точные, правильные результаты, не теряя при этом гибкости разработки.

На первый взгляд запутанно, но на самом деле всё просто.

Первая из таких команд - это **git cherry-pick**. Она выглядит вот так:

> **git cherry-pick** *\<Commit1> \<Commit2> \<...>*

Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (*HEAD*). Мы обожаем **cherry-pick** за то, что в нём очень мало магии и его очень просто понять и применять.

**git cherry-pick** прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши)

Но как быть в случае, когда точно не известно какие коммиты нужны? К счастью, Git позаботился о таких ситуациях! Можно использовать интерактивный **rebase** для этого - лучший способ отобрать набор коммитов для **rebase**.

Всё, что нужно для интерактивного **rebase** - это опция **-i**

> **git rebase -i** *HEAD~4*

Позволяет взаимодействовать с 4 последними коммитами в дереве

Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель **rebase** (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.

Для "реального" Git, этот интерфейс означает просто открытие файла в редакторе типа vim.

После открытия окна интерактивного **rebase** есть три варианта для каждого коммита:

- Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе (у нас в окошке строку с коммитом можно перенести просто мышкой).
- Можно "выкинуть" коммит из ребейза. Для этого есть **pick** - переключение его означает, что нужно выкинуть коммит.
- Наконец, можно соединить коммиты. В этом уровне игры у нас не реализована эта возможность, но, вкратце, при помощи этой функции можно объединять изменения двух коммитов.

# Сложные ситуации
Вот ещё одна ситуация, которая часто случается. Есть некоторые изменения (*newImage*) и другие изменения (*caption*), которые связаны так, что находятся друг поверх друга в репозитории.

Штука в том, что иногда нужно внести небольшие изменения в более ранний коммит. В таком случае надо немного поменять *newImage*, несмотря на то, что коммит уже в прошлом!

Преодолеть эти трудности можно следующим образом:

- Переставить коммит так, чтобы нужный находился наверху при помощи **git rebase -i**
- Внести изменения при помощи **git commit --amend**
- Переставить всё обратно при помощи **git rebase -i**
- И наконец, переместить *main* на изменённую часть дерева, чтобы закончить уровень.

## Теги

В прошлых уроках мы усвоили, что ветки просто двигать туда-сюда и они часто ссылаются на разные коммиты как на изменения данных в ветке. Ветки просто изменить, они часто временны и постоянно меняют своё состояние.

В таком случае, где взять *постоянную* ссылку на момент в истории изменений? Для таких вещей, как релиз, большие слияния нужно нечто более постоянное, чем ветка.

Такое средство имеется. Git предоставляет нам теги, чья основная задача – ссылаться постоянно на конкретный коммит.

Важно, что после создания они никогда не сменят своего положения, так что можно с лёгкостью сделать *checkout* конкретного момента в истории изменений

Создадим тег на C1, который будет нашей версией 1

> **git tag** v1 *C1*

Готово! Всё просто. Мы назвали тег v1 и заставили его ссылаться на *C1* явным образом. Если конкретный коммит не указан, гит пометит тегом *HEAD*.

Теги являются прекрасными ориентирами в истории изменений, поэтому в git есть команда, которая показывает, как далеко текущее состояние от ближайшего тега. И эта команда называется **git describe**

**git describe** помогает сориентироваться после отката на много коммитов по истории изменений. Такое может случиться, когда вы сделали **git bisect** или если вы недавно вернулись из отпуска

> **git describe** *\<ref>*

Где *ref* — это что-либо, что указывает на конкретный коммит. Если не указать *ref*, то git будет считать, что указано текущее положение (*HEAD*).

Вывод команды выглядит примерно так:

> \<tag>_\<numCommits>_g\<hash>

Где *tag* – это ближайший тег в истории изменений, *numCommits* – это на сколько далеко мы от этого тега, а *hash* – это хеш коммита, который описывается.

# Удаленные репозитории
### git clone

До настоящего момента мы были сфокусированы на изучении основ работы с локальным репозиторием (ветвление, слияние, перемещение и т.д.). Однако теперь, когда мы хотим научиться работать с удалёнными репозиториями, нам нужны новые команды для настройки рабочей среды для этих упражнений. Такой командой нам послужит **git clone**

Технически, **git clone** в реальной жизни - это команда, которая *создаст локальную копию удалённого репозитория* (например, с GitHub). На наших занятиях в Learn Git Branching мы используем эту команду немного иначе - **git clone** создаёт удалённый репозиторий на основе вашего локального репозитория. На самом деле, это является полной противоположностью реальной команды, однако такой подход поможет нам наладить связь между склонированным и удалённым репозиторием.

### название удаленных веток
Вы, наверное, догадались, что первый символ **o/** в названии ветки служит для обозначения именно удалённых веток. Да. Удалённые ветки также имеют (обязательное) правило именования - они отображаются в формате:

> *\<удалённый репозиторий>/\<имя ветки>*

Следовательно, если вы взглянете на имя ветки **o/main**, то здесь *main* - это имя ветки, а *o* - это имя удалённого репозитория.

Большинство разработчиков именуют свои главные удалённые репозитории не как o, а как **origin**. Также общепринятым является именование удалённого репозитория как **origin**, когда вы клонируете репозиторий командой **git clone**.

### git fetch
Работа с удалёнными git репозиториями сводится к передаче данных в и из других репозиториев. До тех пор, пока мы можем отправлять коммиты туда-обратно, мы можем делиться любыми изменениями, которые отслеживает git (следовательно, делиться новыми файлами, свежими идеями, любовными письмами и т.д.).

В этом уроке вы научитесь тому, как извлекать данные из удалённого репозитория - и для этого у нас есть соответствующая команда **git fetch**.

**git fetch** выполняет две и только две основные операции. А именно:
- связывается с указанным удалённым репозиторием и забирает все те данные проекта, которых у вас ещё нет, при этом...
- у вас должны появиться ссылки на все ветки из этого удалённого репозитория (например, *o/main*)

Фактически, **git fetch** синхронизирует локальное представление удалённых репозиториев с тем, что является актуальным на текущий момент времени.

Насколько вы помните, в предыдущем уроке мы сказали, что удалённые ветки отображают состояние удалённых репозиториев на тот момент когда вы 'общались' с ними в последний раз. **git fetch** является тем механизмом, который даёт вам возможность общаться с удалёнными репозиториями! Надеюсь, что связь между удалёнными ветками и командой **git fetch** теперь прояснилась.

**git fetch** обычно 'общается' с удалёнными репозиториями посредством Интернета (через такие протоколы, как *http://* или *git://*).

### Чего fetch не делает
Важно отметить, что команда **git fetch** забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент.

Важно это помнить и понимать, потому что многие разработчики думают, что, запустив команду **git fetch**, они приведут всю свою локальную работу к такому же виду, как и на удалённом репозитории. Команда всего лишь скачивает все необходимые данные, но вам потребуется вручную слить эти данные с вашими, когда вы будете готовы. В следующих уроках мы научимся это делать :D

Одним словом, вы можете относиться к **git fetch** как к процедуре скачивания.

### git pull

Теперь, когда мы познакомились с тем, как извлекать данные из удалённого репозитория с помощью **git fetch**, давайте обновим нашу работу, чтобы отобразить все эти изменения!

Существует множество вариантов решений - как только у вас имеется локальный коммит, вы можете соединить его с другой веткой. Это значит, вы можете выполнить одну из команд:

- git cherry-pick o/main
- git rebase o/main
- git merge o/main
- и т.д.

Процедура скачивания (*fetching*) изменений с удалённой ветки и объединения (*merging*) настолько частая и распространённая, что git предоставляет вместо двух команд - одну! Эта команда - **git pull**.

#### Лжекоммиты

> **git fakeTeamwork** \[имя ветки\] *\<количество коммитов>*

инициирует заданное количество коммитов на указанной удаленной ветке

### git push

Хорошо, мы скачали изменения с удалённого репозитория и включили их в наши локальные наработки. Всё это замечательно, но как нам поделиться своими наработками и изменениями с другими участниками проекта?

Способ, которым мы воспользуемся, является противоположным тому способу, которым мы пользовались ранее для скачивания наработок (**git pull**). Этот способ - использование команды **git push**!

Команда **git push** отвечает за загрузку ваших изменений в указанный удалённый репозиторий, а также включение ваших коммитов в состав удалённого репозитория. По окончании работы команды **git push** все ваши друзья смогут скачать себе все сделанные вами наработки.

Вы можете рассматривать команду **git push** как "публикацию" своей работы. Эта команда скрывает в себе множество тонкостей и нюансов, с которыми мы познакомимся в ближайшее время, а пока что давайте начнём с малого...

*замечание - поведение команды **git push** без аргументов варьируется в зависимости от значения **push.default**, указанной в настройках git-а. Значение по умолчанию зависит от версии git, которую вы используете, однако в наших уроках мы будем использовать значение **upstream**. Лучше всегда проверять эту опцию прежде чем push-ить ваши настоящие проекты.*

# Работа в большой команде

Когда вы работаете в составе большой команды разработчиков над проектом, то, вероятнее всего, ветвь main будет заблокирована. Для внесения изменений в неё в git существует понятие запроса на слияние **Pull Request**. В такой ситуации если вы закоммитите свои наработки непосредственно в *main* ветвь, а после выполните **git push**, то будет сгенерировано сообщение об ошибке:

> **! \[remote rejected\] main -> main (TF402455: Pushes to this branch are not permitted; you must use a pull request to update this branch.)**

> *! \[удалённо отклонено\] main -> main (TF402455: Изменение этой ветви запрещены; вы можете использовать pull request для обновления этой ветви.)*

Удалённый репозиторий отклонил загруженные коммиты непосредственно в main ветку потому, что на main _настроена политика_, которая требует использование **Pull request** вместо обычного **git push**.

Эта политика подразумевает процесс создания новой ветви разработки, внесение в неё всех необходимых коммитов, загрузка изменений в удалённый репозиторий и открытие нового **Pull request**. Однако вы забыли про это и закоммитили наработки непосредственно в *main* ветвь. Теперь вы застряли и не можете запушить свои изменения

## Слияние фича-бранчей

Теперь, когда вы умело владеете командами *fetch*, *pull* и *push*, давайте применим эти навыки в сочетании с новым рабочим процессом (он же workflow).

Среди разработчиков, вовлечённых в большой проект, довольно распространён приём — выполнять всю свою работу в так называемых фича-бранчах (вне main). А затем, как только работа выполнена, разработчик интегрирует всё, что было им сделано. Всё это, за исключением одного шага, похоже на предыдущий урок (там, где мы закачивали ветки на удалённый репозиторий)

Ряд разработчиков делают **push** и **pull** лишь на локальную ветку *main* - таким образом ветка main всегда синхронизирована с тем, что находится на удалённом репозитории (o/main).

Для этого рабочего процесса мы совместили две вещи:

- интеграцию фича-бранчей в main
- закачку (**push**) и скачку (**pull**) с удалённого репозитория

## rebase или merge?
В среде разработчиков существует огромное количество дебатов около merging и rebasing. Ниже приведены основные *за и против* метода **rebasing**:

**За:**

- Rebasing делает дерево коммитов более чистым и читабельным, потому что всё представляется единой прямой линией.

**Против:**

- Метод rebasing явно изменяет историю коммитов в дереве.

Например, коммит C1 может быть перебазирован после C3. Соответственно, в дереве работа над C1' будет отображаться как идущая после C3, хотя на самом деле она была выполнена раньше.

Некоторые разработчики любят сохранять историю и предпочитают слияние (merging). Другие (такие как я) предпочитают иметь чистое дерево коммитов, и пользуются перебазировкой (rebasing). Всё зависит от ваших предпочтений и вкусов :D

## Удаленные-отслеживаемые ветки

Единственное, что могло бы показаться вам "магией" в нескольких предыдущих уроках - это то, как git знает, что ветка *main* соответствует *o/main*. Конечно, эти ветки имеют схожие имена и связь между локальной и удалённой ветками *main* выглядит вполне логично, однако, эта связь наглядно продемонстрирована в двух сценариях:

- Во время операции **pull** коммиты скачиваются в ветку *o/main* и затем соединяются в ветку *main*. Подразумеваемая цель слияния определяется исходя из этой связи.
- Во время операции **push** наработки из ветки main закачиваются на удалённую ветку *main* (которая в локальном представлении выглядит как *o/main*). Пункт назначения операции **push** определяется исходя из связи между *main* и *o/main*.

Короче, связь между *main* и *o/main* объясняется не иначе как свойство "удалённое отслеживание" веток. Ветка *main* настроена так, чтобы следить за *o/main* -- это подразумевает наличие источника для **merge** и пункта назначения для **push** в контексте ветки *main*.

Вы, должно быть, удивлены, как это отслеживание появилось на ветке *main*, если мы не запускали ни одной специфической команды. На самом деле, когда вы клонируете репозиторий, это слежение включается автоматически.

В процессе клонирования git локально создаёт удалённые ветки для каждой ветки с удалённого репозитория (такие как *o/main*). Затем он - git - создаёт локальные ветки, которые отслеживают текущую, активную ветку на удалённом репозитории. В большинстве случаев - это *main*.

К тому моменту как **git clone** завершит своё выполнение, у вас будет лишь одна локальная ветка (так что вы ещё не сильно перегружены), но, если вам будет интересно, вы сможете увидеть все удалённые ветки (при желании).

Именно это объясняет, почему сразу после клонирования вы видите в консоли надпись:

> *local branch "main" set to track remote branch "o/main" (локальная ветка "main" теперь следит за удалённой веткой "o/main")*

### А могу ли я сделать это самостоятельно?

Само собой! Вы можете сказать любой из веток, чтобы она отслеживала *o/main*, и если вы так сделаете, эта ветка будет иметь такой же пункт назначения для **push** и **merge** как и локальная ветка *main*. Это значит, что вы можете выполнить **git push**, находясь на ветке *totallyNotMain*, и все ваши наработки с ветки *totallyNotMain* будут закачены на ветку *main* удалённого репозитория!

Есть два способа сделать это. Первый - это выполнить **checkout** для новой ветки, указав удалённую ветку в качестве ссылки. Для этого необходимо выполнить команду:

> **git checkout -b** *totallyNotMain o/main*

, которая создаст новую ветку с именем *totallyNotMain* и укажет ей следить за *o/main*

Другой способ указать ветке отслеживать удалённую ветку — это просто использовать команду **git branch -u**. Выполнив команду:

> **git branch -u** *o/main foo*

вы укажете ветке *foo* следить за *o/main*. А если вы ещё при этом находитесь на ветке *foo*, то её можно не указывать:

> **git branch -u** *o/main*

## Аргументы команды push

Отлично! Теперь, когда вы знаете, как следить за удалёнными ветками, мы можем начать изучение того, что скрыто под занавесом работы команд *git push*, *fetch* и *pull*. Мы будем рассматривать одну команду за другой, однако принципы у них очень схожи.

Сперва взглянем на **git push**. В уроке, посвящённом слежению за удалённым репозиторием, вы узнали о том, что git находит удалённый репозиторий и ветку, в которую необходимо push-ить, благодаря свойствам текущей ветки, на которой мы находимся. Это так называемое поведение без аргументов, однако команда **git push** может быть также использована и с аргументами. Вид команды в данном случае:

> **git push** *\<удалённый_репозиторий> \<целевая_ветка>*

Что за такой параметр *\<целевая_ветка>*? Мы узнаем об этом через секунду, а пока что рассмотрим пример. Допустим, что мы выполняем такую команду:

> *git push origin main*

дословный перевод с английского будет таким:

*Перейди в ветку с именем "main" в моём локальном репозитории, возьми все коммиты и затем перейди на ветку "main" на удалённом репозитории "origin.". На эту удалённую ветку скопируй все отсутствующие коммиты, которые есть у меня, и скажи, когда ты закончишь.*

Указывая *main* в качестве аргумента *"целевая_ветка"*, мы тем самым говорим git-у откуда будут приходить и уходить наши коммиты. Аргумент *"целевая_ветка"* или *"местонахождение"* - это синхронизация между двумя репозиториями.

Имейте в виду, что с тех пор, как мы сказали git-у всё, что ему необходимо (указав оба аргумента), ему - git-у - абсолютно всё равно, что вы зачекаутили до этого

### Подробности аргумента <пункт назначения>

Помните, когда в прошлом занятии мы указали в качестве аргумента ветку *main* для команды **git push**, мы указали совместно источник, откуда будут приходить коммиты, и пункт назначения (получатель), куда коммиты будут уходить.

Однако, вы, наверное, задаётесь вопросом - а что, если я хочу, чтобы мои **источник и получатель коммитов были различными**? Что, если мы хотим запушить коммиты из локальной ветки *foo* в ветку *bar* на удалённом репозитории?

В том случае, когда вам необходимо разделить источник и получатель аргумента *\<пункт назначения>*, соедините их вместе, используя двоеточие:

> **git push origin** *\<источник>:\<получатель>*

Обычно это называется **refspec**. **Refspec** — это всего лишь модное имя для определения местоположения, которое git может распознать (например, ветка foo или просто HEAD~1)

Как только вы указали источник и получатель независимо друг от друга, вы можете довольно причудливо и точно использовать команды для работы с удалёнными ветками и репозиториями.

## Аргументы команды fetch

Итак, мы только что изучили всё, что касается аргументов **git push**, мы узнали о параметре *\<пункт назначения>*, и даже об аргументе, задающем отдельно источник и получатель коммитов (*\<источник>:\<получатель>*). Можем ли мы применить все эти полученные знания для команды **git fetch**?

Ещё бы! Аргументы для команды **git fetch** на самом деле очень, очень похожи на те, что мы использовали в **git push**. В данном случае применяется тот же подход, только в противоположном направлении (так как теперь вы скачиваете коммиты, а не закачиваете их).

Если вы указываете пункт назначения в команде **git fetch**, например так, как в следующем примере:

> *git fetch origin foo*

Git отправится в ветку *foo* на удалённом репозитории, соберёт с собой все коммиты, которые не присутствуют локально, и затем поместит их в локальную ветку под названием *o/foo*.

## Странный <источник>

Git использует параметр <источник> странным образом. Странность заключается в том, что Вы можете оставить пустым параметр *\<источник>* для команд **git push** и **git fetch**:

- *git push origin :side*
- *git fetch origin :bugFix*

Что же будет с веткой, на которую мы делаем **git push** с пустым аргументом *\<источник>*? Она будет удалена!

Наконец, если мы попытаемся притянуть изменения(**git fetch**) из "ничего" к нам в локальный репозиторий, то это создаст у нас новую ветку.

## Аргументы для pull

Аргументы для **git pull** не покажутся вам чем-то новым, учитывая, что вы уже знакомы с аргументами для **git fetch** и **git push**

Как мы помним, **git pull** сначала выполняет **git fetch**, а следом сразу **git merge** с той веткой, в которую притянулись обновления командой *fetch*. Другими словами, это все равно, что выполнить **git fetch** с теми же аргументами, которые вы указали для *pull*, а затем выполнить **git merge** с веткой, указанной в аргументе *\<приемник>* команды *pull*.

**Вот примеры абсолютно эквивалентных команд в git:**

> *git pull origin foo*

то же самое, что и:

> *git fetch origin foo; git merge o/foo*

**И еще:**

> *git pull origin bar~1:bugFix*

то же что, и:

> *git fetch origin bar~1:bugFix; git merge bugFix*

Как видно, **git pull** используется, чтобы за одну команду выполнить **fetch + merge**.
