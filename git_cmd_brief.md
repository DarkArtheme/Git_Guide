## Работа с удаленным репозиторием

### git remote 
* по умолчанию выводит список удаленных репозиториев
* ключ **-v** позволяет посмотреть адреса для чтения и записи 
* чтобы добавить удаленный репозиторий и присвоить ему имя используется:
    
     >**git remote add [shortname] [url]** 

* чтобы получить больше информации об удаленном репозитории используется:
    
    >**git remote show [remote-name]**

* для переименования удаленного репозитория можно выполнить:

    >**git remote rename [old_name] [new_name]**
    
* чтобы удалить удаленный репозиторий используется:

    >**git remote rm [remote-name]**

### git fetch [remote-name]
* забирает все изменения с сервера, которых нет в локальном репозитории
* никак не меняет текущую ветку (изменяется только ветка *remote-name*)

### git pull
* если коротко, то это git fetch + git merge (или + git rebase)
* т.е. забирает все изменения с сервера и сливает их с текущей веткой

### git clone
* если коротко, то это git init + git pull
* т.е. создает локальный репозиторий и берет данные из удаленного репозитория

### git push [remote-name] [branch-name]
* отправка изменений на удаленный репозиторий
* работает только если есть права на запись и были получены все изменения с
    удаленного репозитория
* следующий формат команды отправит локальную ветку *serverfix* в ветку *awesomebranch*
    удаленного репозитория:
    >**git push origin serverfix:awesomebranch**


# Ветвление

### git branch
* по умолчанию выводит список доступных веток (с ключом **-v** 
    выведется последний коммит в каждой ветке)
* если после команды ввести **[branch-name]**, то будет создана ветка с этим названием
* ключ **-d** позволяет удалить ветку
* опция --merged позволяет увидеть ветки, слитые с текущей (ветки, которые при 
    выводе не отмечены '*' можно удалить)
* опция --no-merged позволяет увидеть ветки, содержащие наработки и которые еще 
    не были слиты с текущей веткой.
* опция --move позволяет переименовать ветку:
    >**git branch --move [bad-branch-name] [corrected-branch-name]**

    чтобы отправить это изменение в удаленный репозиторий, используется:
    >**git push --set-upstream origin [corrected-branch-name]**
    
    >**git push origin --delete [bad-branch-name]**

### git checkout [branch-name]
* переключение на выбранную ветку
* при переключении ветки происходит изменение файлов в рабочем каталоге
* ключ **-b** позволяет создать ветку с выбранным именем и сразу на нее переключиться
* можно включить отслеживание ветки следующими способами:
    * сокращенная форма:
        >**git checkout --track origin/serverfix**
    
    * форма с возможностью менять название результирующей ветки:
        >**git checkout -b sf origin/serverfix**

### git switch
* начиная с версии git 2.23 можно использовать вместо git checkout
* чтобы создать новую ветку и переключиться на нее, нужно выполнить:
    >**git switch -c [new-branch-name]**

* чтобы вернуться к предыдущей извлеченной ветке достаточно ввести:
    >**git switch -**

### git merge [branch-name]
* сливает ветку branch-name с текущей
* операция слияния не совершается, если встречается конфликт
* конфликт считается разрешенным, если конфликтный файл был вручную добавлен в индекс
* для создания коммита слияния после разрешения конфликта используется 
    **git commit**

### git mergetool
* графический инструмент для разрешения конфликтов слияния

### git rebase [branch-name]
* выполняет перебазирование ветки branch-name, т.е. текущая ветка устанавливается
    на последний коммит ветки, поверх которой выполняется перебазирование (branch-name)
* далее можно произвести слияние перемоткой
* результат ничем не отличается от трехстороннего слияния, но история коммитов чище